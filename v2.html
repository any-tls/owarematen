<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>一致するまで終われまテン - Complete Ver.</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&family=Nunito:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --kahoot-purple: #46178f;
            --kahoot-blue: #1368ce;
            --correct-green: #26890c;
            --gold: #ffa602;
        }
        body {
            font-family: 'Mochiy Pop One', sans-serif;
            background-color: #f2f2f2;
            overflow: hidden; /* アプリライクな挙動のため */
            touch-action: pan-x pan-y;
        }
        /* 背景パターン */
        .bg-pattern {
            background-color: var(--kahoot-purple);
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%235c24b3' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        /* 配信モード用レイアウト */
        .streamer-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: #1a1a1a;
        }
        .streamer-frame {
            width: 1280px;
            height: 720px;
            background: var(--kahoot-purple);
            position: relative;
            overflow: hidden;
            border: 4px solid var(--gold);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            flex-shrink: 0;
            transform-origin: center;
        }
        /* 配信モード時にIDを外に出すエリア */
        .streamer-safe-area {
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 1.5rem;
            text-align: center;
        }

        /* 通常モード */
        .normal-wrapper {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* 手書きキャンバス */
        canvas {
            touch-action: none;
            cursor: crosshair;
            background: white;
            border-radius: 12px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        /* カラーパレット選択 */
        .color-btn {
            position: relative;
            transition: transform 0.1s;
        }
        .color-btn:active { transform: scale(0.9); }
        .color-check {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* アニメーション */
        .animate-pop { animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .btn-push {
            transition: all 0.1s;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        .btn-push:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.2);
        }
        
        /* ドラッグ&ドロップゾーン */
        .drop-zone {
            border: 3px dashed #cbd5e1;
            transition: all 0.3s;
        }
        .drop-zone.drag-active {
            border-color: var(--kahoot-blue);
            background-color: rgba(19, 104, 206, 0.1);
        }
    </style>
</head>
<body class="text-gray-800" @dragover.prevent @drop.prevent>

<div id="app" class="h-full w-full" @drop.prevent="handleGlobalDrop" @dragover.prevent>
    <div class="fixed inset-0 bg-pattern -z-10"></div>

    <div :class="streamerMode ? 'streamer-wrapper' : 'normal-wrapper'">
        
        <div v-if="streamerMode && roomCode" class="streamer-safe-area">
            <span class="bg-indigo-600 px-4 py-2 rounded-lg">ROOM ID: {{ roomCode }}</span>
            <button @click="toggleStreamerMode" class="ml-4 text-sm bg-gray-700 px-3 py-1 rounded">配信モードOFF</button>
        </div>

        <div :class="streamerMode ? 'streamer-frame' : 'flex-1 flex flex-col relative w-full min-h-full'" class="bg-white/10 backdrop-blur-sm transition-all duration-300">
            
            <div class="bg-white/90 p-3 shadow-md flex justify-between items-center z-20 sticky top-0">
                <h1 class="text-lg md:text-xl font-bold text-indigo-800 truncate"><i class="fas fa-pen-fancy"></i> 一致するまで終われまテン</h1>
                <div class="flex gap-2 items-center flex-shrink-0">
                    <button v-if="isHost && !streamerMode" @click="toggleStreamerMode" class="text-xs bg-gray-800 text-white px-2 py-1 rounded btn-push">
                        <i class="fas fa-video"></i> 配信モード
                    </button>
                    <span v-if="roomCode && !streamerMode" class="bg-indigo-600 text-white px-3 py-1 rounded-full font-mono font-bold text-sm md:text-base">ID: {{ roomCode }}</span>
                </div>
            </div>

            <div v-if="scene === 'home'" class="flex-1 flex flex-col justify-center items-center p-4 gap-6 animate-pop overflow-y-auto">
                <div class="bg-white p-8 rounded-2xl shadow-xl text-center max-w-md w-full border-b-8 border-indigo-200">
                    <h2 class="text-2xl md:text-3xl font-bold mb-6 text-indigo-700">GAME START</h2>
                    <div class="grid grid-cols-1 gap-4">
                        <button @click="setupHost" class="bg-indigo-600 hover:bg-indigo-700 text-white py-4 rounded-xl font-bold text-lg btn-push w-full">
                            部屋を作る (Host)
                        </button>
                        <button @click="scene = 'join_room_id'" class="bg-green-500 hover:bg-green-600 text-white py-4 rounded-xl font-bold text-lg btn-push w-full">
                            部屋に入る (Player)
                        </button>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'host_setup'" class="flex-1 flex flex-col p-4 overflow-y-auto">
                <div class="bg-white p-6 rounded-2xl shadow-xl max-w-2xl w-full mx-auto animate-pop my-auto">
                    <h3 class="text-xl font-bold mb-4 border-b pb-2">ルーム設定</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-bold mb-1">問題リストの登録</label>
                            <p class="text-xs text-gray-500 mb-2">※カンマ(,)区切り または 改行で区切ってください。<br>※テキストファイルを画面にドロップしても読み込めます。</p>
                            
                            <textarea v-model="rawQuestionText" class="w-full h-32 p-2 border-2 border-gray-300 rounded-lg focus:border-indigo-500" placeholder="例：ラーメンの味といえば？, 好きなおにぎりの具は？"></textarea>
                            
                            <div class="flex gap-2 mt-2">
                                <label class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg font-bold text-sm transition text-center flex-1">
                                    <i class="fas fa-file-upload"></i> ファイル選択
                                    <input type="file" class="hidden" accept=".txt" @change="handleFileSelect">
                                </label>
                                <button @click="loadDefaultQuestions" class="bg-yellow-100 text-yellow-800 px-4 py-2 rounded-lg font-bold text-sm hover:bg-yellow-200 transition">
                                    公式問題をロード
                                </button>
                            </div>
                        </div>

                        <div class="flex items-center justify-between bg-gray-50 p-3 rounded-lg">
                            <span class="font-bold text-sm">出題順序</span>
                            <div class="flex bg-gray-200 rounded-lg p-1">
                                <button @click="config.order = 'random'" :class="config.order === 'random' ? 'bg-white shadow text-indigo-600' : 'text-gray-500'" class="px-4 py-1 rounded transition text-sm font-bold">ランダム</button>
                                <button @click="config.order = 'sequential'" :class="config.order === 'sequential' ? 'bg-white shadow text-indigo-600' : 'text-gray-500'" class="px-4 py-1 rounded transition text-sm font-bold">順番通り</button>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-bold mb-1">目標一致回数</label>
                            <input type="number" v-model.number="config.targetMatches" class="w-20 p-2 border rounded text-center" min="1" max="50"> 回
                        </div>

                        <button @click="createRoom" class="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold btn-push mt-4">
                            部屋を作成して開始
                        </button>
                        <button @click="scene = 'home'" class="w-full text-gray-500 py-2">戻る</button>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'join_room_id'" class="flex-1 flex justify-center items-center p-4">
                <div class="bg-white p-6 rounded-2xl shadow-xl max-w-sm w-full animate-pop">
                    <h3 class="text-xl font-bold mb-4">部屋IDを入力</h3>
                    <input v-model="joinRoomId" @keyup.enter="connectToRoom" type="tel" maxlength="6" placeholder="123456" class="w-full p-4 text-3xl text-center font-mono tracking-widest border-2 border-gray-200 rounded-xl mb-4 focus:border-green-500 outline-none">
                    <button @click="connectToRoom" class="w-full bg-green-500 text-white py-3 rounded-xl font-bold btn-push">
                        次へ
                    </button>
                    <button @click="scene = 'home'" class="w-full text-gray-500 py-2 mt-2">戻る</button>
                </div>
            </div>

            <div v-if="scene === 'join_name'" class="flex-1 flex justify-center items-center p-4">
                <div class="bg-white p-6 rounded-2xl shadow-xl max-w-sm w-full animate-pop">
                    <h3 class="text-xl font-bold mb-4">ニックネーム</h3>
                    <input v-model="playerName" @keyup.enter="enterLobby" placeholder="名前を入力" class="w-full p-4 text-xl text-center border-2 border-gray-200 rounded-xl mb-4 focus:border-green-500 outline-none">
                    <button @click="enterLobby" class="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold btn-push">
                        参加する！
                    </button>
                </div>
            </div>

            <div v-if="scene === 'lobby'" class="flex-1 p-6 flex flex-col items-center overflow-y-auto">
                <div class="bg-white/90 p-4 rounded-xl shadow-lg mb-6 text-center w-full max-w-2xl animate-pop">
                    <p v-if="isHost" class="text-indigo-600 font-bold text-lg mb-2">参加者待機中...</p>
                    <p v-else class="text-indigo-600 font-bold text-lg mb-2">ホストの開始を待っています...</p>
                    
                    <div class="bg-gray-100 rounded-lg p-4">
                        <div class="text-sm text-gray-500 mb-2">現在の参加者 ({{ Object.keys(participants).length }}人)</div>
                        <div class="flex flex-wrap gap-2 justify-center">
                            <span v-for="p in participants" :key="p.id" class="bg-white px-3 py-1 rounded-full shadow font-bold text-indigo-800">
                                {{ p.name }}
                            </span>
                        </div>
                    </div>
                </div>

                <button v-if="isHost" @click="startGame" class="bg-indigo-600 text-white px-12 py-4 rounded-full font-bold text-xl shadow-lg btn-push animate-pulse">
                    ゲームスタート！
                </button>
            </div>

            <div v-if="scene === 'game_question'" class="flex-1 flex flex-col w-full h-full">
                <div class="bg-indigo-900 text-white p-4 text-center shrink-0 shadow-lg z-10">
                    <p class="text-xs opacity-80 mb-1">お題 {{ currentRound }}/∞</p>
                    <h2 class="text-2xl md:text-4xl font-black">{{ currentTopic }}</h2>
                </div>

                <div v-if="isHost" class="flex-1 flex flex-col items-center justify-center p-4 bg-gray-100">
                    <div class="text-center mb-8">
                        <p class="text-xl text-gray-600 font-bold mb-2">回答待ち...</p>
                        <div class="text-6xl font-mono font-bold text-indigo-600">
                            {{ Object.keys(answers).length }} / {{ Object.keys(participants).length }}
                        </div>
                    </div>
                    <button @click="startJudging" class="bg-yellow-400 text-indigo-900 px-10 py-4 rounded-full font-bold text-2xl btn-push shadow-xl border-4 border-yellow-200">
                        締め切って判定！
                    </button>
                </div>

                <div v-else class="flex-1 flex flex-col items-center p-2 overflow-y-auto w-full">
                    <div v-if="!hasAnswered" class="w-full max-w-md flex flex-col items-center gap-4 py-2">
                        
                        <div class="bg-white rounded-xl shadow-lg p-2 w-full">
                            <div class="flex justify-between items-center mb-2 px-1">
                                <span class="text-xs font-bold text-gray-400"><i class="fas fa-paintbrush"></i> 手書き</span>
                                <button @click="clearCanvas" class="text-xs bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-gray-700 font-bold"><i class="fas fa-trash"></i> 消す</button>
                            </div>
                            <div ref="canvasContainer" class="w-full h-48 md:h-64 border bg-white rounded touch-none relative cursor-crosshair overflow-hidden">
                                <canvas ref="drawCanvas" class="absolute inset-0 w-full h-full"></canvas>
                            </div>
                        </div>

                        <div class="flex flex-wrap gap-2 justify-center w-full max-w-sm">
                            <button v-for="c in colors" :key="c.val" @click="setPenColor(c.val)" 
                                class="w-8 h-8 rounded-full border-2 border-white shadow color-btn"
                                :style="{backgroundColor: c.val}">
                                <i v-if="penColor === c.val" class="fas fa-check color-check"></i>
                            </button>
                        </div>

                        <div class="w-full">
                            <input v-model="myAnswerText" @keyup.enter="submitAnswer" placeholder="テキストでも回答できます" class="w-full p-3 border-2 border-gray-300 rounded-xl focus:border-indigo-500 outline-none">
                        </div>

                        <button @click="submitAnswer" class="bg-indigo-600 text-white w-full py-4 rounded-xl font-bold text-xl btn-push mt-2">
                            回答を送信
                        </button>
                    </div>

                    <div v-else class="flex-1 flex flex-col items-center justify-center animate-pop text-center">
                        <div class="text-6xl text-green-500 mb-4"><i class="fas fa-check-circle"></i></div>
                        <h3 class="text-2xl font-bold">送信完了！</h3>
                        <p class="text-gray-500">みんなの回答を待っています...</p>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'judging'" class="flex-1 flex flex-col p-2 overflow-hidden bg-gray-100">
                <div class="flex justify-between items-center p-3 bg-white shadow-sm z-10 shrink-0">
                    <h2 class="font-bold text-indigo-800">
                        現在の不一致数: {{ currentMatches }}/{{ config.targetMatches }}
                    </h2>
                    <div v-if="isHost" class="flex gap-2">
                        <button @click="handleMatch(false)" class="bg-gray-500 text-white px-4 py-2 rounded font-bold btn-push text-sm">不一致 (次へ)</button>
                        <button @click="handleMatch(true)" class="bg-pink-500 text-white px-6 py-2 rounded font-bold btn-push shadow-lg border-2 border-pink-300">
                            <i class="fas fa-heart"></i> 全員一致！
                        </button>
                    </div>
                    <div v-else class="text-sm font-bold text-gray-500 animate-pulse">判定中...</div>
                </div>

                <div class="flex-1 overflow-y-auto p-2">
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 pb-20">
                        <div v-for="(ans, pid) in answers" :key="pid" class="bg-white rounded-xl shadow p-2 flex flex-col items-center min-h-[150px] animate-pop relative border-4 border-white hover:border-indigo-100 transition">
                            <div class="flex-1 flex items-center justify-center w-full overflow-hidden p-1">
                                <img v-if="ans.image" :src="ans.image" class="max-w-full max-h-[120px] object-contain">
                                <div v-else class="text-xl font-bold text-center break-words w-full">{{ ans.text }}</div>
                            </div>
                            <div class="mt-1 text-xs font-bold text-gray-500 bg-gray-100 px-2 py-1 rounded-full">
                                {{ participants[pid]?.name }}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'result'" class="flex-1 flex flex-col justify-center items-center p-4 bg-indigo-900 text-white">
                <div class="animate-pop text-center">
                    <h2 class="text-4xl md:text-6xl font-black mb-4 text-yellow-400 drop-shadow-md">CONGRATULATIONS!</h2>
                    <p class="text-xl mb-8">みんなの心が一つになりました！</p>
                    <button v-if="isHost" @click="location.reload()" class="bg-white text-indigo-900 px-8 py-3 rounded-full font-bold text-xl btn-push hover:bg-gray-100">
                        タイトルに戻る
                    </button>
                </div>
            </div>

        </div>
    </div>
</div>

<script>
const { createApp, ref, reactive, nextTick, computed } = Vue;

createApp({
    setup() {
        // --- State ---
        const scene = ref('home'); // home, host_setup, join_room_id, join_name, lobby, game_question, judging, result
        const streamerMode = ref(false);
        
        // Host Data
        const isHost = ref(false);
        const roomCode = ref('');
        const rawQuestionText = ref('');
        const questionQueue = ref([]);
        const currentRound = ref(0);
        const currentMatches = ref(0);
        const config = reactive({
            order: 'random', // 'random' | 'sequential'
            targetMatches: 10
        });

        // Player Data
        const playerName = ref('');
        const joinRoomId = ref('');
        const myPeerId = ref('');
        const participants = reactive({}); // { peerId: { name } } (Host NOT included)
        
        // Game State
        const currentTopic = ref('');
        const answers = reactive({}); // { peerId: { text, image } }
        const hasAnswered = ref(false);
        const myAnswerText = ref('');
        
        // Drawing
        const canvasContainer = ref(null);
        const drawCanvas = ref(null);
        const penColor = ref('#000000');
        const colors = [
            { val: '#000000', label: '黒' }, { val: '#e21b3c', label: '赤' }, 
            { val: '#1368ce', label: '青' }, { val: '#facc15', label: '黄' },
            { val: '#22c55e', label: '緑' }, { val: '#f97316', label: '橙' },
            { val: '#a855f7', label: '紫' }, { val: '#9ca3af', label: '灰' },
            { val: '#fdba74', label: '薄橙' }
        ];
        let ctx = null;
        let isDrawing = false;
        let lastX = 0; let lastY = 0;

        // PeerJS
        let peer = null;
        let connections = {}; // Host stores all, Client stores host conn

        // --- Logic: Host Setup ---
        const setupHost = async () => {
            isHost.value = true;
            scene.value = 'host_setup';
            // Pre-load default
            loadDefaultQuestions();
        };

        const loadDefaultQuestions = () => {
            if(!rawQuestionText.value) {
                rawQuestionText.value = "ラーメンの味といえば？,好きなおにぎりの具は？,きのこ派？たけのこ派？,SNSといえば？,お金持ちといえば？,山といえ場？,夏休みの宿題はいつやる？,目玉焼きには何をかける？,カレーの具といえば？,寿司のネタといえば？";
            }
        };

        const handleFileSelect = (e) => {
            const file = e.target.files[0];
            if(!file) return;
            readFile(file);
        };
        
        const handleGlobalDrop = (e) => {
            if(scene.value !== 'host_setup') return;
            const file = e.dataTransfer.files[0];
            if(file && file.type.startsWith('text')) {
                readFile(file);
            }
        };

        const readFile = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                if(rawQuestionText.value) rawQuestionText.value += "\n" + text;
                else rawQuestionText.value = text;
            };
            reader.readAsText(file);
        };

        const createRoom = async () => {
            // Process questions
            let qs = rawQuestionText.value.split(/[,,\n]/).map(s => s.trim()).filter(s => s);
            if(qs.length === 0) return alert('問題を登録してください');
            
            questionQueue.value = qs;
            
            // Generate Code
            const code = Math.floor(100000 + Math.random() * 900000).toString();
            roomCode.value = code;
            
            await initPeer(`k10app-${code}`);
            
            scene.value = 'lobby';
        };

        // --- Logic: Join ---
        const connectToRoom = async () => {
            if (joinRoomId.value.length !== 6) return alert('6桁のIDを入力してください');
            
            // Connect to PeerJS cloud first to get my ID
            await initPeer();
            
            const hostId = `k10app-${joinRoomId.value}`;
            const conn = peer.connect(hostId);
            
            conn.on('open', () => {
                connections['host'] = conn;
                // Connection successful, move to name input
                scene.value = 'join_name';
                
                // Handle receiving data from host
                conn.on('data', handleClientData);
                conn.on('close', () => alert('ホストとの接続が切れました'));
            });
            
            conn.on('error', (err) => {
                alert('部屋が見つかりません');
                scene.value = 'join_room_id';
            });
        };

        const enterLobby = () => {
            if(!playerName.value) return alert('名前を入力してください');
            // Send Join Request
            connections['host'].send({ type: 'JOIN', name: playerName.value });
            scene.value = 'lobby';
        };

        // --- Logic: PeerJS Core ---
        const initPeer = (id = null) => {
            return new Promise((resolve) => {
                peer = new Peer(id, { debug: 1 });
                peer.on('open', (id) => {
                    myPeerId.value = id;
                    resolve(id);
                });
                peer.on('connection', (conn) => {
                    // Host Logic: Accept connection
                    if(!isHost.value) return; 
                    
                    conn.on('data', (data) => {
                        if(data.type === 'JOIN') {
                            participants[conn.peer] = { name: data.name };
                            connections[conn.peer] = conn;
                            broadcastState();
                        }
                        if(data.type === 'ANSWER') {
                            answers[conn.peer] = data.answer;
                        }
                    });
                    
                    conn.on('close', () => {
                        delete participants[conn.peer];
                        delete connections[conn.peer];
                        broadcastState();
                    });
                });
            });
        };

        const broadcast = (data) => {
            for(let id in connections) {
                connections[id].send(data);
            }
        };

        const broadcastState = () => {
            if(!isHost.value) return;
            broadcast({
                type: 'STATE_UPDATE',
                participants: participants,
                roomCode: roomCode.value
            });
        };

        const handleClientData = (data) => {
            if(data.type === 'STATE_UPDATE') {
                Object.assign(participants, data.participants);
                roomCode.value = data.roomCode;
            }
            if(data.type === 'START_ROUND') {
                currentTopic.value = data.topic;
                config.targetMatches = data.target;
                currentMatches.value = data.currentMatches;
                currentRound.value = data.round;
                
                scene.value = 'game_question';
                hasAnswered.value = false;
                myAnswerText.value = '';
                nextTick(initCanvas);
            }
            if(data.type === 'START_JUDGING') {
                Object.assign(answers, data.answers); // Sync answers to clients
                scene.value = 'judging';
            }
            if(data.type === 'ROUND_RESULT') {
                 currentMatches.value = data.currentMatches;
                 if(data.win) {
                     // Wait a bit or show some effect? Direct next round for now
                 }
            }
            if(data.type === 'GAME_END') {
                scene.value = 'result';
            }
        };

        // --- Logic: Game Flow (Host) ---
        const startGame = () => {
            currentMatches.value = 0;
            currentRound.value = 0;
            nextRound();
        };

        const nextRound = () => {
            // Pick Question
            if(questionQueue.value.length === 0) {
                alert('問題が尽きました！最初からループします');
                loadDefaultQuestions();
            }

            let qIndex = 0;
            if(config.order === 'random') {
                qIndex = Math.floor(Math.random() * questionQueue.value.length);
            }
            currentTopic.value = questionQueue.value[qIndex];
            
            // Remove used if needed, or keep. Let's keep for infinite play, or remove?
            // User said "Start before setting order". Let's just pick.
            
            currentRound.value++;
            
            // Clear Answers
            for(let k in answers) delete answers[k];

            broadcast({
                type: 'START_ROUND',
                topic: currentTopic.value,
                target: config.targetMatches,
                currentMatches: currentMatches.value,
                round: currentRound.value
            });
            scene.value = 'game_question';
        };

        const startJudging = () => {
            broadcast({
                type: 'START_JUDGING',
                answers: answers
            });
            scene.value = 'judging';
        };

        const handleMatch = (isMatch) => {
            if(isMatch) {
                currentMatches.value++;
                if(currentMatches.value >= config.targetMatches) {
                    broadcast({ type: 'GAME_END' });
                    scene.value = 'result';
                } else {
                    // Success effect logic could go here
                    alert('一致！ナイス！');
                    nextRound();
                }
            } else {
                nextRound();
            }
        };

        // --- Logic: Drawing & Input ---
        const initCanvas = () => {
            if(!drawCanvas.value || !canvasContainer.value) return;
            const canvas = drawCanvas.value;
            const container = canvasContainer.value;
            
            // High DPI scaling
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            ctx = canvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 3;
            ctx.strokeStyle = penColor.value;

            // Events
            const getPos = (e) => {
                const r = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - r.left, y: clientY - r.top };
            };

            const start = (e) => {
                isDrawing = true;
                const p = getPos(e);
                lastX = p.x; lastY = p.y;
            };
            const move = (e) => {
                if(!isDrawing) return;
                e.preventDefault(); // Stop scroll
                const p = getPos(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
                lastX = p.x; lastY = p.y;
            };
            const end = () => isDrawing = false;

            // Touch & Mouse
            canvas.addEventListener('mousedown', start);
            canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, {passive: false});
            canvas.addEventListener('touchmove', move, {passive: false});
            canvas.addEventListener('touchend', end);
        };

        const setPenColor = (c) => {
            penColor.value = c;
            if(ctx) ctx.strokeStyle = c;
        };

        const clearCanvas = () => {
            if(ctx) ctx.clearRect(0, 0, drawCanvas.value.width, drawCanvas.value.height);
        };

        const submitAnswer = () => {
            let image = null;
            if (drawCanvas.value) {
                // Check if canvas has content
                const pixels = ctx.getImageData(0,0, drawCanvas.value.width, drawCanvas.value.height).data;
                const hasContent = pixels.some(p => p !== 0);
                if(hasContent) image = drawCanvas.value.toDataURL('image/png');
            }

            if(!image && !myAnswerText.value) return alert('回答を入力してください');

            // 優先順位: テキスト入力があればテキスト、なければ画像
            // ※「両方表示」ではなく「どちらか」が基本だが、データ構造は両方送る
            
            connections['host'].send({
                type: 'ANSWER',
                answer: {
                    text: myAnswerText.value,
                    image: image
                }
            });
            hasAnswered.value = true;
        };

        // --- Util ---
        const toggleStreamerMode = () => streamerMode.value = !streamerMode.value;

        return {
            scene, streamerMode, isHost, roomCode, joinRoomId, playerName, participants,
            rawQuestionText, config, currentTopic, answers, hasAnswered, myAnswerText,
            drawCanvas, canvasContainer, penColor, colors, currentMatches, currentRound,
            setupHost, loadDefaultQuestions, handleFileSelect, handleGlobalDrop, createRoom,
            connectToRoom, enterLobby, startGame, startJudging, handleMatch,
            initCanvas, setPenColor, clearCanvas, submitAnswer, toggleStreamerMode
        };
    }
}).mount('#app');
</script>
</body>
</html>
