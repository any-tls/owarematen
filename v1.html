<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>一致するまで終われまテン - Custom Game</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&family=Nunito:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --kahoot-purple: #46178f;
            --kahoot-blue: #1368ce;
            --kahoot-light-blue: #86d4f6;
            --correct-green: #26890c;
            --wrong-red: #e21b3c;
            --gold: #ffa602;
        }
        body {
            font-family: 'Mochiy Pop One', sans-serif;
            background-color: #f2f2f2;
            overflow-x: hidden;
            touch-action: none; /* 全体のスクロール防止（手書きのため） */
        }
        .bg-pattern {
            background-color: var(--kahoot-purple);
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%235c24b3' fill-opacity='0.4'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        
        /* 配信モード：固定レイアウト */
        .streamer-mode-container {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000; /* OBSでクロマキーもしやすいように黒、またはグリーン可 */
        }
        .streamer-frame {
            width: 1280px; /* 固定サイズ */
            height: 720px;
            background: var(--kahoot-purple);
            position: relative;
            overflow: hidden;
            border: 4px solid var(--gold);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* アニメーション */
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop {
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes correctPulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(38, 137, 12, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(38, 137, 12, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(38, 137, 12, 0); }
        }
        .card-correct {
            background-color: var(--correct-green) !important;
            color: white;
            animation: correctPulse 0.5s ease-out;
            border-color: #fff !important;
        }
        .card-wrong {
            background-color: var(--wrong-red) !important;
            color: white;
            opacity: 0.8;
        }

        /* 手書きキャンバス */
        canvas {
            touch-action: none;
            cursor: crosshair;
            background: white;
            border-radius: 12px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }

        /* UI要素 */
        .btn-push {
            box-shadow: 0 6px 0 rgba(0,0,0,0.2);
            transition: all 0.1s;
        }
        .btn-push:active {
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
            transform: translateY(4px);
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            padding: 1rem;
        }
    </style>
</head>
<body class="text-gray-800 h-screen w-screen overflow-hidden">

<div id="app" class="h-full w-full">
    <div class="fixed inset-0 bg-pattern -z-10"></div>

    <div :class="{'streamer-mode-container': streamerMode, 'h-full w-full flex flex-col': !streamerMode}">
        <div :class="{'streamer-frame': streamerMode, 'flex-1 flex flex-col relative w-full h-full overflow-y-auto': !streamerMode}" class="bg-white/10 backdrop-blur-sm">

            <div class="bg-white/90 p-3 shadow-md flex justify-between items-center z-20">
                <h1 class="text-xl font-bold text-indigo-800"><i class="fas fa-pen-fancy"></i> 一致するまで終われまテン</h1>
                <div class="flex gap-2">
                    <button v-if="isHost" @click="toggleStreamerMode" class="text-xs bg-gray-800 text-white px-2 py-1 rounded btn-push">
                        <i class="fas fa-video"></i> {{ streamerMode ? '配信OFF' : '配信ON' }}
                    </button>
                    <span v-if="roomCode" class="bg-indigo-600 text-white px-3 py-1 rounded-full font-mono font-bold">ROOM: {{ roomCode }}</span>
                </div>
            </div>

            <div v-if="scene === 'home'" class="flex-1 flex flex-col justify-center items-center p-4 gap-6 animate-pop">
                <div class="bg-white p-8 rounded-2xl shadow-xl text-center max-w-md w-full border-b-8 border-indigo-200">
                    <h2 class="text-3xl font-bold mb-6 text-indigo-700">GAME START</h2>
                    
                    <div class="space-y-4">
                        <input v-model="playerName" placeholder="ニックネームを入力" class="w-full p-4 text-xl text-center border-2 border-indigo-100 rounded-xl focus:outline-none focus:border-indigo-500 transition">
                        
                        <div class="grid grid-cols-2 gap-4">
                            <button @click="showHostSetup" class="bg-indigo-600 hover:bg-indigo-700 text-white py-4 rounded-xl font-bold text-lg btn-push w-full">
                                部屋を作る (Host)
                            </button>
                            <button @click="showJoinSetup" class="bg-green-500 hover:bg-green-600 text-white py-4 rounded-xl font-bold text-lg btn-push w-full">
                                部屋に入る
                            </button>
                        </div>
                    </div>
                    <div v-if="reconnectAvailable" class="mt-4">
                        <button @click="reconnect" class="text-sm text-indigo-500 underline">前回のゲームに復帰する</button>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'host_setup'" class="flex-1 flex justify-center items-center p-4">
                <div class="bg-white p-6 rounded-2xl shadow-xl max-w-lg w-full animate-pop">
                    <h3 class="text-xl font-bold mb-4">ルーム設定</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-bold mb-1">入力モード</label>
                            <div class="flex gap-2">
                                <button @click="config.inputMode = 'both'" :class="config.inputMode === 'both' ? 'bg-indigo-600 text-white' : 'bg-gray-200'" class="flex-1 py-2 rounded-lg font-bold transition">両方</button>
                                <button @click="config.inputMode = 'text'" :class="config.inputMode === 'text' ? 'bg-indigo-600 text-white' : 'bg-gray-200'" class="flex-1 py-2 rounded-lg font-bold transition">テキストのみ</button>
                            </div>
                        </div>

                        <div>
                            <label class="block text-sm font-bold mb-1">終了条件（一致数）</label>
                            <input type="number" v-model.number="config.targetMatches" class="w-full p-2 border rounded" min="1" max="50">
                        </div>

                        <div>
                            <label class="block text-sm font-bold mb-1">Groq API Key (AI自動判定用/任意)</label>
                            <input type="password" v-model="config.apiKey" placeholder="gsk_..." class="w-full p-2 border rounded text-xs font-mono">
                            <p class="text-xs text-gray-500 mt-1">※設定なしでも手動判定で遊べます。キーは保存されません。</p>
                        </div>

                        <button @click="createRoom" class="w-full bg-indigo-600 text-white py-3 rounded-xl font-bold btn-push mt-4">
                            部屋を作成
                        </button>
                        <button @click="scene = 'home'" class="w-full text-gray-500 py-2">戻る</button>
                    </div>
                </div>
            </div>

            <div v-if="scene === 'join_setup'" class="flex-1 flex justify-center items-center p-4">
                <div class="bg-white p-6 rounded-2xl shadow-xl max-w-sm w-full animate-pop">
                    <h3 class="text-xl font-bold mb-4">部屋IDを入力</h3>
                    <input v-model="joinRoomId" type="tel" maxlength="6" placeholder="123456" class="w-full p-4 text-3xl text-center font-mono tracking-widest border-2 border-gray-200 rounded-xl mb-4">
                    <button @click="joinRoom" class="w-full bg-green-500 text-white py-3 rounded-xl font-bold btn-push">
                        参加する
                    </button>
                    <button @click="scene = 'home'" class="w-full text-gray-500 py-2 mt-2">戻る</button>
                </div>
            </div>

            <div v-if="scene === 'lobby'" class="flex-1 p-6 flex flex-col items-center">
                <div class="bg-white/90 p-4 rounded-xl shadow-lg mb-6 text-center w-full max-w-2xl animate-pop">
                    <p class="text-gray-500 font-bold mb-1">ROOM ID</p>
                    <div class="text-5xl font-mono font-black text-indigo-600 tracking-wider mb-2">{{ roomCode }}</div>
                    <p v-if="isHost" class="text-sm">参加者が集まるのを待っています...</p>
                    <p v-else class="text-sm">ホストが開始するのを待っています...</p>
                </div>

                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 w-full max-w-4xl">
                    <div v-for="p in participants" :key="p.id" class="bg-white p-3 rounded-lg shadow flex items-center justify-between animate-pop">
                        <span class="font-bold truncate">{{ p.name }}</span>
                        <button v-if="isHost && p.id !== myPeerId" @click="kickParticipant(p.id)" class="text-red-400 hover:text-red-600">
                            <i class="fas fa-times-circle"></i>
                        </button>
                    </div>
                </div>

                <div v-if="isHost" class="fixed bottom-8 left-0 right-0 flex justify-center">
                    <button @click="startGame" class="bg-indigo-600 text-white px-12 py-4 rounded-full font-bold text-xl shadow-lg btn-push animate-pulse">
                        ゲームスタート！
                    </button>
                </div>
            </div>

            <div v-if="scene === 'game_question' && isHost" class="flex-1 flex flex-col justify-center items-center p-8 text-center bg-indigo-900 text-white">
                <h2 class="text-2xl mb-4 opacity-80">今回のお題</h2>
                <div class="text-5xl md:text-7xl font-black mb-8 animate-pop bg-white/10 p-8 rounded-xl backdrop-blur-md border-4 border-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.5)]">
                    {{ currentTopic }}
                </div>
                <div class="text-xl animate-pulse">回答を待っています...</div>
                <div class="mt-8 text-3xl font-mono">{{ Object.keys(answers).length }} / {{ Object.keys(participants).length }} 回答済</div>
                
                <button @click="startJudging" class="mt-12 bg-yellow-400 text-indigo-900 px-8 py-3 rounded-full font-bold text-xl btn-push">
                    回答を締め切る
                </button>
            </div>

            <div v-if="scene === 'game_question' && !isHost" class="flex-1 flex flex-col p-4">
                <div class="bg-white p-4 rounded-xl shadow-md mb-4 text-center">
                    <p class="text-gray-500 text-sm">お題</p>
                    <h2 class="text-2xl font-bold text-indigo-800">{{ currentTopic }}</h2>
                </div>

                <div v-if="!hasAnswered" class="flex-1 flex flex-col items-center justify-center">
                    
                    <div v-if="config.inputMode === 'both'" class="w-full max-w-md bg-white rounded-xl shadow-lg p-2 mb-4">
                        <div class="flex justify-between items-center mb-2 px-2">
                            <span class="text-xs font-bold text-gray-400"><i class="fas fa-paintbrush"></i> 手書き</span>
                            <div class="flex gap-2">
                                <button @click="setPenColor('#000000')" class="w-6 h-6 rounded-full bg-black border-2" :class="penColor=='#000000'?'border-indigo-500':'border-transparent'"></button>
                                <button @click="setPenColor('#e21b3c')" class="w-6 h-6 rounded-full bg-red-600 border-2" :class="penColor=='#e21b3c'?'border-indigo-500':'border-transparent'"></button>
                                <button @click="setPenColor('#1368ce')" class="w-6 h-6 rounded-full bg-blue-600 border-2" :class="penColor=='#1368ce'?'border-indigo-500':'border-transparent'"></button>
                                <button @click="clearCanvas" class="text-xs bg-gray-200 px-2 py-1 rounded"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                        <canvas ref="drawCanvas" width="350" height="200" class="w-full touch-none border bg-white"></canvas>
                    </div>

                    <div class="w-full max-w-md">
                        <input v-model="myAnswerText" placeholder="テキストで回答（手書きがあれば手書き優先）" class="w-full p-4 border-2 border-gray-300 rounded-xl mb-4 text-lg">
                    </div>

                    <button @click="submitAnswer" class="bg-indigo-600 text-white w-full max-w-md py-4 rounded-xl font-bold text-xl btn-push">
                        回答する！
                    </button>
                </div>

                <div v-else class="flex-1 flex flex-col items-center justify-center animate-pop">
                    <div class="text-6xl text-green-500 mb-4"><i class="fas fa-check-circle"></i></div>
                    <h3 class="text-2xl font-bold">回答送信完了！</h3>
                    <p class="text-gray-500">ホストの進行を待っています...</p>
                </div>
            </div>

            <div v-if="scene === 'judging'" class="flex-1 flex flex-col p-2 overflow-hidden">
                <div class="flex justify-between items-center p-4 bg-white/80 rounded-lg mb-2">
                    <h2 class="text-xl font-bold">正誤判定</h2>
                    <div class="text-right">
                        <span class="text-sm font-bold text-gray-500">現在の一致数</span>
                        <div class="text-3xl font-black text-indigo-600">{{ currentCorrectCount }} / {{ config.targetMatches }}</div>
                    </div>
                </div>

                <div class="flex-1 overflow-y-auto card-grid content-start">
                    <div v-for="(ans, pid) in answers" :key="pid" 
                         class="bg-white rounded-xl shadow-md p-3 flex flex-col items-center justify-between min-h-[160px] border-4 transition-all duration-300 relative cursor-pointer"
                         :class="{'card-correct': ans.status === 'correct', 'card-wrong': ans.status === 'wrong', 'border-white': !ans.status, 'border-indigo-100': !ans.status}"
                         @click="isHost ? toggleJudgment(pid) : null">
                        
                        <div v-if="ans.aiSuggestion !== undefined && ans.status === 'pending' && isHost" 
                             class="absolute top-2 right-2 text-xs px-2 py-1 rounded-full font-bold shadow"
                             :class="ans.aiSuggestion ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'">
                            AI: {{ ans.aiSuggestion ? '○' : '×' }}
                        </div>

                        <div class="flex-1 flex items-center justify-center w-full">
                            <img v-if="ans.image" :src="ans.image" class="max-w-full max-h-[100px] object-contain">
                            <div v-else class="text-2xl font-bold text-center break-words w-full">{{ ans.text }}</div>
                        </div>
                        <div class="mt-2 text-sm font-bold opacity-70 bg-black/10 px-2 rounded-full">{{ participants[pid]?.name }}</div>
                        
                        <div v-if="isHost && ans.status === 'pending'" class="absolute inset-0 bg-black/5 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity rounded-lg">
                            <span class="bg-white text-black px-3 py-1 rounded-full shadow font-bold">クリックで判定</span>
                        </div>
                    </div>
                </div>

                <div v-if="isHost" class="p-4 bg-white/90 shadow-lg flex justify-center gap-4">
                    <button @click="applyAiJudgments" v-if="config.apiKey" class="bg-purple-500 text-white px-6 py-3 rounded-full font-bold btn-push text-sm">
                        <i class="fas fa-robot"></i> AI判定を適用
                    </button>
                    <button @click="finalizeRound" class="bg-indigo-600 text-white px-8 py-3 rounded-full font-bold text-lg btn-push">
                        結果を確定して次へ
                    </button>
                </div>
            </div>

            <div v-if="scene === 'result'" class="flex-1 flex flex-col justify-center items-center p-4 bg-indigo-900 text-white">
                <div class="animate-pop text-center">
                    <h2 class="text-4xl font-black mb-4 text-yellow-400 drop-shadow-md">FINISH!</h2>
                    <p class="text-xl mb-8">目標の一致数に到達しました！</p>
                    
                    <div class="bg-white text-indigo-900 p-8 rounded-2xl shadow-2xl max-w-2xl w-full">
                        <h3 class="text-2xl font-bold mb-6">最終結果</h3>
                        <div class="flex flex-wrap justify-center gap-4">
                            <div v-for="p in participants" :key="p.id" class="flex flex-col items-center">
                                <div class="w-16 h-16 rounded-full bg-indigo-100 flex items-center justify-center text-2xl font-bold mb-2">
                                    {{ getScore(p.id) }}
                                </div>
                                <span class="font-bold text-sm">{{ p.name }}</span>
                            </div>
                        </div>
                    </div>

                    <button v-if="isHost" @click="resetGame" class="mt-12 bg-white text-indigo-900 px-8 py-3 rounded-full font-bold text-xl btn-push hover:bg-gray-100">
                        タイトルに戻る
                    </button>
                </div>
            </div>

            <div v-if="showTopicInput" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                <div class="bg-white p-6 rounded-2xl shadow-xl w-full max-w-md animate-pop">
                    <h3 class="text-xl font-bold mb-4">お題を入力</h3>
                    <input v-model="nextTopic" placeholder="例：おにぎりの具といえば？" class="w-full p-3 border-2 border-indigo-200 rounded-xl mb-4 text-lg">
                    <div class="flex gap-2">
                        <button @click="startRound" class="flex-1 bg-indigo-600 text-white py-3 rounded-xl font-bold">開始</button>
                        <button @click="showTopicInput=false" class="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl font-bold">キャンセル</button>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>

<script>
const { createApp, ref, reactive, onMounted, nextTick, computed } = Vue;

createApp({
    setup() {
        // --- State ---
        const scene = ref('home'); // home, host_setup, join_setup, lobby, game_question, judging, result
        const playerName = ref('');
        const joinRoomId = ref('');
        const roomCode = ref('');
        const isHost = ref(false);
        const streamerMode = ref(false);
        const participants = reactive({}); // { peerId: { id, name, score } }
        const config = reactive({ inputMode: 'both', targetMatches: 10, apiKey: '' });
        const currentTopic = ref('');
        const showTopicInput = ref(false);
        const nextTopic = ref('');
        
        // Game State
        const answers = reactive({}); // { peerId: { text, image, status: 'pending'|'correct'|'wrong', aiSuggestion: bool } }
        const hasAnswered = ref(false);
        const myAnswerText = ref('');
        const myPeerId = ref('');
        const currentCorrectCount = ref(0);

        // Drawing
        const drawCanvas = ref(null);
        const penColor = ref('#000000');
        let ctx = null;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // PeerJS
        let peer = null;
        let connections = {}; // Host stores all, Client stores host conn

        // --- Lifecycle ---
        onMounted(() => {
            // LocalStorage Check
            const savedName = localStorage.getItem('k10_name');
            if (savedName) playerName.value = savedName;
        });

        const reconnectAvailable = computed(() => {
            return localStorage.getItem('k10_room') && localStorage.getItem('k10_name');
        });

        // --- Core Logic ---

        // 1. Initialize Peer
        const initPeer = (id = null) => {
            return new Promise((resolve, reject) => {
                peer = new Peer(id, {
                    debug: 1
                });
                peer.on('open', (id) => {
                    myPeerId.value = id;
                    resolve(id);
                });
                peer.on('connection', handleConnection);
                peer.on('error', (err) => console.error(err));
            });
        };

        // 2. Host Logic
        const createRoom = async () => {
            if (!playerName.value) return alert('名前を入力してください');
            
            // Generate 6 digit code
            const code = Math.floor(100000 + Math.random() * 900000).toString();
            roomCode.value = code;
            isHost.value = true;
            
            // ID Prefix to avoid collision in public server
            const peerId = `k10app-${code}`;
            
            await initPeer(peerId);
            
            // Add self
            participants[myPeerId.value] = { id: myPeerId.value, name: playerName.value, score: 0 };
            
            localStorage.setItem('k10_room', code);
            localStorage.setItem('k10_name', playerName.value);
            
            scene.value = 'lobby';
        };

        const kickParticipant = (id) => {
            if(confirm('追放しますか？')) {
                if(connections[id]) {
                    connections[id].send({ type: 'KICKED' });
                    connections[id].close();
                }
                delete participants[id];
                broadcastState();
            }
        };

        const startGame = () => {
            showTopicInput.value = true;
        };

        const startRound = () => {
            currentTopic.value = nextTopic.value;
            showTopicInput.value = false;
            
            // Reset Round State
            for(let key in answers) delete answers[key];
            
            const data = {
                type: 'START_ROUND',
                topic: currentTopic.value,
                config: config
            };
            broadcast(data);
            
            scene.value = 'game_question';
            // Setup self if host plays (Host usually doesn't play in this format, but let's allow it conceptually or just manage)
            // In this app, Host is Game Master.
        };

        const startJudging = async () => {
            scene.value = 'judging';
            broadcast({ type: 'START_JUDGING' });
            
            // AI Pre-check
            if(config.apiKey) {
                for(const pid in answers) {
                    const ans = answers[pid];
                    if(ans.text && !ans.image) {
                        checkWithAI(pid, ans.text, currentTopic.value);
                    }
                }
            }
        };

        const toggleJudgment = (pid) => {
            const ans = answers[pid];
            if(ans.status === 'pending' || ans.status === 'wrong') {
                ans.status = 'correct';
            } else {
                ans.status = 'wrong';
            }
            // Update UI immediately
            updateScore();
        };
        
        const applyAiJudgments = () => {
            for(const pid in answers) {
                const ans = answers[pid];
                if(ans.aiSuggestion !== undefined && ans.status === 'pending') {
                    ans.status = ans.aiSuggestion ? 'correct' : 'wrong';
                }
            }
            updateScore();
        };
        
        const updateScore = () => {
            let count = 0;
            for(const pid in answers) {
                if(answers[pid].status === 'correct') count++;
            }
            currentCorrectCount.value = count;
        };

        const finalizeRound = () => {
            // Check Win Condition
            if(currentCorrectCount.value >= config.targetMatches) {
                broadcast({ type: 'GAME_END', winners: participants });
                scene.value = 'result';
            } else {
                // Loop
                broadcast({ type: 'ROUND_END' });
                showTopicInput.value = true;
                scene.value = 'game_question'; // Briefly before modal
            }
        };

        // 3. Client Logic
        const joinRoom = async () => {
            if (!playerName.value || !joinRoomId.value) return alert('入力してください');
            
            await initPeer(); // Random ID
            
            const hostId = `k10app-${joinRoomId.value}`;
            const conn = peer.connect(hostId);
            
            conn.on('open', () => {
                connections['host'] = conn;
                conn.send({ type: 'JOIN', name: playerName.value });
                
                localStorage.setItem('k10_room', joinRoomId.value);
                localStorage.setItem('k10_name', playerName.value);
            });
            
            conn.on('data', handleData);
            conn.on('close', () => alert('接続が切れました'));
        };
        
        const reconnect = async () => {
            joinRoomId.value = localStorage.getItem('k10_room');
            playerName.value = localStorage.getItem('k10_name');
            joinRoom();
        };

        // 4. Communication Handlers
        const handleConnection = (conn) => {
            connections[conn.peer] = conn;
            conn.on('data', (data) => {
                if(isHost.value) handleHostData(data, conn.peer);
            });
            conn.on('close', () => {
                // Handle disconnect (optional: keep in list for reconnect)
            });
        };

        const handleHostData = (data, peerId) => {
            if (data.type === 'JOIN') {
                participants[peerId] = { id: peerId, name: data.name, score: 0 };
                broadcastState(); // Update everyone's lobby
            }
            if (data.type === 'ANSWER') {
                answers[peerId] = {
                    text: data.text,
                    image: data.image,
                    status: 'pending'
                };
            }
        };

        const handleData = (data) => {
            if (data.type === 'UPDATE_STATE') {
                Object.assign(participants, data.participants);
                if(scene.value === 'home') scene.value = 'lobby';
                roomCode.value = data.roomCode;
            }
            if (data.type === 'START_ROUND') {
                scene.value = 'game_question';
                currentTopic.value = data.topic;
                Object.assign(config, data.config);
                hasAnswered.value = false;
                myAnswerText.value = '';
                // Init Canvas
                if(config.inputMode === 'both') {
                    nextTick(initCanvas);
                }
            }
            if (data.type === 'START_JUDGING') {
                scene.value = 'judging'; // Client sees "Judging..." screen (simplified)
            }
            if (data.type === 'GAME_END') {
                scene.value = 'result';
            }
            if (data.type === 'KICKED') {
                alert('追放されました');
                location.reload();
            }
        };

        const broadcast = (data) => {
            for (const id in connections) {
                connections[id].send(data);
            }
        };

        const broadcastState = () => {
            broadcast({
                type: 'UPDATE_STATE',
                participants: participants,
                roomCode: roomCode.value
            });
        };

        // 5. Game Actions
        const submitAnswer = () => {
            let image = null;
            if (drawCanvas.value) {
                // Check if canvas is not empty (simple check)
                image = drawCanvas.value.toDataURL('image/png');
                // If mostly white, assume text only (Skipping complex check for simplicity)
            }

            const payload = {
                type: 'ANSWER',
                text: myAnswerText.value,
                image: (config.inputMode === 'both' && !myAnswerText.value) ? image : null
            };
            
            // If both text and image, decide priority. Logic: if text exists, send text for AI, image for display?
            // Request says: "Host sees Text OR Handwriting".
            // Let's send image if drawn, text if typed. If both, send Image with Text metadata?
            // Simple logic: If text input has value, use text. Else use image.
            
            if(myAnswerText.value) {
                 payload.image = null; // Prioritize text for AI judging if typed
            }

            connections['host'].send(payload);
            hasAnswered.value = true;
        };

        // 6. AI Logic (Groq)
        const checkWithAI = async (pid, answer, question) => {
            if(!config.apiKey) return;
            
            try {
                const prompt = `
                Question: "${question}"
                Answer: "${answer}"
                Is this answer generally considered correct or relevant in a common sense context?
                Reply ONLY with JSON: {"correct": true} or {"correct": false}.
                `;
                
                const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        messages: [{ role: "user", content: prompt }],
                        model: "llama3-8b-8192",
                        response_format: { type: "json_object" },
                        max_tokens: 10
                    })
                });
                
                const data = await res.json();
                const json = JSON.parse(data.choices[0].message.content);
                if(answers[pid]) {
                    answers[pid].aiSuggestion = json.correct;
                }
            } catch(e) {
                console.error("AI Error", e);
            }
        };

        // 7. Canvas Logic
        const initCanvas = () => {
            const canvas = drawCanvas.value;
            if(!canvas) return;
            
            // Resize for high DPI
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx = canvas.getContext('2d');
            ctx.scale(2, 2);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 3;
            ctx.strokeStyle = penColor.value;

            // Events
            const start = (e) => {
                isDrawing = true;
                const { x, y } = getPos(e);
                lastX = x;
                lastY = y;
            };
            const move = (e) => {
                if(!isDrawing) return;
                const { x, y } = getPos(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.quadraticCurveTo(lastX, lastY, (lastX + x) / 2, (lastY + y) / 2); // Simple smoothing
                ctx.lineTo(x, y);
                ctx.stroke();
                lastX = x;
                lastY = y;
            };
            const end = () => isDrawing = false;

            canvas.addEventListener('pointerdown', start);
            canvas.addEventListener('pointermove', move);
            canvas.addEventListener('pointerup', end);
            canvas.addEventListener('pointerleave', end);
        };
        
        const getPos = (e) => {
            const rect = drawCanvas.value.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        };
        
        const setPenColor = (c) => {
            penColor.value = c;
            if(ctx) ctx.strokeStyle = c;
        };
        
        const clearCanvas = () => {
            if(!ctx) return;
            const canvas = drawCanvas.value;
            ctx.clearRect(0, 0, canvas.width/2, canvas.height/2); // Scale fix
        };

        // Util
        const toggleStreamerMode = () => streamerMode.value = !streamerMode.value;
        const resetGame = () => location.reload();
        const getScore = (id) => "★"; // Placeholder for score logic

        return {
            scene, playerName, joinRoomId, roomCode, isHost, streamerMode, participants, config,
            currentTopic, showTopicInput, nextTopic, answers, hasAnswered, myAnswerText, myPeerId,
            currentCorrectCount, drawCanvas, penColor,
            createRoom, joinRoom, reconnect, reconnectAvailable, kickParticipant,
            startGame, startRound, startJudging, toggleJudgment, applyAiJudgments, finalizeRound,
            submitAnswer, showHostSetup: () => scene.value='host_setup', showJoinSetup: () => scene.value='join_setup',
            toggleStreamerMode, setPenColor, clearCanvas, getScore, resetGame
        };
    }
}).mount('#app');
</script>
</body>
</html>
